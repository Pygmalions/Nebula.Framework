using System.Reflection;
using Nebula.Proxying;

namespace Nebula.Prism;

public class PropertyProxyEntry : IExtensibleProperty
{
    /// <inheritdoc />
    public event Action<AccessContext> Getting
    {
        add => _gettingHandlers.Add(value);
        remove => _gettingHandlers.Remove(value);
    }
    /// <inheritdoc />
    public event Action<AccessContext> AfterGetting
    {
        add => _afterGettingHandlers.Add(value);
        remove => _afterGettingHandlers.Remove(value);
    }
    
    /// <inheritdoc />
    public event Action<AccessContext> Setting
    {
        add => _settingHandlers.Add(value);
        remove => _settingHandlers.Remove(value);
    }
    /// <inheritdoc />
    public event Action<AccessContext> AfterSetting
    {
        add => _afterSettingHandlers.Add(value);
        remove => _afterSettingHandlers.Remove(value);
    }
    
    /// <inheritdoc />
    public object ProxiedHolder { get; }
    
    /// <inheritdoc />
    public PropertyInfo ProxiedProperty { get; }
    
    /// <inheritdoc />
    public bool NullValueAccepted { get; }

    /// <summary>
    /// Set of registered handlers for pre-process event.
    /// </summary>
    private readonly HashSet<Action<AccessContext>> _gettingHandlers = new();
    /// <summary>
    /// Set of registered handlers for post-process event.
    /// </summary>
    private readonly HashSet<Action<AccessContext>> _afterGettingHandlers = new();
    /// <summary>
    /// Set of registered handlers for pre-process event.
    /// </summary>
    private readonly HashSet<Action<AccessContext>> _settingHandlers = new();
    /// <summary>
    /// Set of registered handlers for post-process event.
    /// </summary>
    private readonly HashSet<Action<AccessContext>> _afterSettingHandlers = new();

    public PropertyProxyEntry(object holder, PropertyInfo property)
    {
        ProxiedHolder = holder;
        ProxiedProperty = property;
        
        NullValueAccepted = 
            ProxiedProperty.PropertyType.IsGenericType &&
            ProxiedProperty.PropertyType.GetGenericTypeDefinition() == typeof(Nullable<>);
    }
    
    public object? Get()
    {
        throw new Exception("Manual invoking a property proxy generated by Prism is not allowed.");
    }

    public void Set(object? value)
    {
        throw new Exception("Manual invoking a property proxy generated by Prism is not allowed.");
    }

    public void TriggerGettingEvent(AccessContext context)
    {
        Parallel.ForEach(_gettingHandlers, action => action.Invoke(context));
        if (context.ThrowingException != null)
            throw context.ThrowingException;
        if (context.Interrupted && context.AccessingValue == null && !NullValueAccepted)
            throw new Exception("Proxied property getting interrupted without acceptable return value.");
        if (context.Skipped && context.AccessingValue == null && !NullValueAccepted)
            throw new Exception("Proxied property getting skipped without acceptable return value.");
    }

    public void TriggerAfterGettingEvent(AccessContext context)
    {
        Parallel.ForEach(_afterGettingHandlers, action => action.Invoke(context));

        if (context.ThrowingException != null)
            throw context.ThrowingException;
    }
    
    public void TriggerSettingEvent(AccessContext context)
    {
        Parallel.ForEach(_settingHandlers, action => action.Invoke(context));
        if (context.ThrowingException != null)
            throw context.ThrowingException;
        if (context.Interrupted && context.AccessingValue == null && !NullValueAccepted)
            throw new Exception("Proxied property setting interrupted without acceptable return value.");
        if (context.Skipped && context.AccessingValue == null && !NullValueAccepted)
            throw new Exception("Proxied property setting skipped without acceptable return value.");
    }

    public void TriggerAfterSettingEvent(AccessContext context)
    {
        Parallel.ForEach(_afterSettingHandlers, action => action.Invoke(context));

        if (context.ThrowingException != null)
            throw context.ThrowingException;
    }
}